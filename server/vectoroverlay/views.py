from rest_framework import generics
from .serializers import DataUploadSerializer
from rest_framework import viewsets
from rest_framework.response import Response
from rest_framework import status
from .models import *
from .script import create_vector_overlay

from ImportForce_TXT import ImportForce_TXT
from FindContactIntervals import FindContactIntervals
from findplate import findplate
from pixelratios import pix2m_fromplate, bw2pix
from dataconversion_force import convertdata
from VectorOverlay.vectoroverlay import vectoroverlay


class DataUploader_Viweset(viewsets.ModelViewSet):
    serializer_class = DataUploadSerializer
    queryset = UploadedData.objects.all()
    # Use this if filtering of data is required
    # filterset_fields = ['samplingRate','userID']   

    def create(self, request, *args, **kwargs):
        # set up headers and other parameters to send back a response
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)

        print("HERE", request.POST)

        # # Alternate / easier method to get video url
        # video_file_post = request.POST.get('videoFile')
        # print(video_file_post)

        # Set video paths
        file1_force = serializer.data.get('textFile')
        file1_video = serializer.data.get('videoFile')

        # Set output path
        file1_vid_new = file1_video[:-4]+ '_OL.mp4'

        # Currently hardcoded plate names
        fp1 = 'Attila49'
        fp2 = 'Ryan52'
        sampvid_f1 = 120
        contactframe_f1 = 163-1 
        data_f1_raw, samp, bw = ImportForce_TXT(file1_force)
        ci_f1 = FindContactIntervals((data_f1_raw['Attila49 9286BA_Fz'] +data_f1_raw['Ryan52 9286BA_Fz']),samp,thresh=16)
        data_f1 = {0: data_f1_raw.filter(regex = fp1).iloc[ci_f1['Start'][0]:ci_f1['End'][0],:],
                1: data_f1_raw.filter(regex = fp2).iloc[ci_f1['Start'][0]:ci_f1['End'][0],:]}
        plate_area = findplate(file1_video ,framestart=0, label = 'Insert image here')


        pix2m = pix2m_fromplate(plate_area, (0.9,0.6))
        mag2pix = bw2pix(pix2m['x'], bw, bwpermeter=2)

        flip = {0: ['fy', 'ax'],
                1: ['fy', 'ax']}
        
        transform_data = convertdata(data_f1, mag2pix, pix2m, view='fy', mode='combined', platelocs=plate_area, flip=flip)

        transform_data.data2pix()

        data_pix_f1 = transform_data.data_fp

        vectoroverlay(file1_video, file1_vid_new, data_pix_f1, contactframe_f1, samp_force=samp, samp_video=sampvid_f1, dispthresh=2)

        
        return Response({'videoFile': file1_force}, status=status.HTTP_201_CREATED, headers=headers)

        # In case we decide to seperate out the script from views
        # # Run the Python script using subprocess
        # script_path = video_file_url
        # command = ['python', script_path, video_file]
        # process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # stdout, stderr = process.communicate()

        # # Check if the script ran successfully
        # if process.returncode == 0:
        #     # Assuming the new video file is generated by the script
        #     new_video_file = 'path/to/new/video.mp4'  # Replace with the actual path to the new video file

        #     # Read the new video file as binary data
        #     with open(new_video_file, 'rb') as file:
        #         response = file.read()

        #     # Set the appropriate response headers
        #     response_headers = {
        #         'Content-Type': 'video/mp4',  # Adjust the content type based on the actual video format
        #         'Content-Disposition': 'attachment; filename="new_video.mp4"',  # Replace with the desired filename
        #     }

        #     return HttpResponse(response, headers=response_headers, status=status.HTTP_201_CREATED)
        # else:
        #     # Handle the case when the script encountered an error
        #     error_message = stderr.decode('utf-8')
        #     return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    